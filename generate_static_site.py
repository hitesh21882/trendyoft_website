#!/usr/bin/env python3
"""
Generate static HTML site with products from database
This allows the site to work even when the server is not running
"""

import pymysql
import json
import os
from datetime import datetime
from dotenv import load_dotenv

# Load environment variables
load_dotenv()

# Database configuration
DB_CONFIG = {
    'host': os.getenv('host_name'),
    'port': 3306,
    'user': os.getenv('db_username'),
    'password': os.getenv('db_password'),
    'database': os.getenv('database_name'),
    'charset': 'utf8mb4',
    'autocommit': True,
    'cursorclass': pymysql.cursors.DictCursor
}

def get_products_from_database():
    """Fetch all products from database"""
    try:
        connection = pymysql.connect(**DB_CONFIG)
        with connection.cursor() as cursor:
            cursor.execute("""
                SELECT id, title, description, price, quantity, category, 
                       image_full_url, image_main_url, image_thumb_url, 
                       created_at, updated_at, is_active 
                FROM products 
                WHERE is_active = TRUE 
                ORDER BY created_at DESC
            """)
            products = cursor.fetchall()
        connection.close()
        return products
    except Exception as e:
        print(f"Error fetching products: {e}")
        return []

def generate_static_products_js():
    """Generate JavaScript file with products data"""
    products = get_products_from_database()
    
    # Format products for JavaScript
    js_products = []
    for product in products:
        js_product = {
            'id': product['id'],
            'title': product['title'],
            'description': product['description'],
            'price': float(product['price']),
            'quantity': product['quantity'],
            'category': product['category'],
            'image_url': product.get('image_main_url', ''),
            'images': {
                'thumbnail': product.get('image_thumb_url', ''),
                'main': product.get('image_main_url', ''),
                'original': product.get('image_full_url', '')
            },
            'created_at': product['created_at'].isoformat() if product.get('created_at') else '',
            'updated_at': product['updated_at'].isoformat() if product.get('updated_at') else None,
            'is_active': product.get('is_active', True)
        }
        js_products.append(js_product)
    
    # Create JavaScript file with products data
    js_content = f"""
// Auto-generated products data - {datetime.now().isoformat()}
// Generated by generate_static_site.py

window.STATIC_PRODUCTS = {json.dumps(js_products, indent=2)};

// Categories data
window.STATIC_CATEGORIES = {json.dumps(get_categories_data(js_products), indent=2)};

console.log('Loaded {{}} products from static data'.replace('{{}}', window.STATIC_PRODUCTS.length));
"""
    
    with open('static_products.js', 'w', encoding='utf-8') as f:
        f.write(js_content)
    
    print(f"‚úÖ Generated static_products.js with {len(js_products)} products")
    return len(js_products)

def get_categories_data(products):
    """Generate categories data from products"""
    categories = {}
    for product in products:
        category = product['category']
        if category not in categories:
            categories[category] = {'name': category, 'count': 0}
        categories[category]['count'] += 1
    
    return list(categories.values())

def update_index_html():
    """Update index.html to use static data when server is not available"""
    try:
        with open('index.html', 'r', encoding='utf-8') as f:
            html_content = f.read()
        
        # Add static products script before closing body tag
        if 'static_products.js' not in html_content:
            # Insert script tag before closing body tag
            html_content = html_content.replace(
                '</body>',
                '    <!-- Static products data for offline use -->\n    <script src="static_products.js"></script>\n</body>'
            )
            
            # Add fallback logic to existing JavaScript
            js_fallback = """
    // Fallback to static data if API fails
    async function fetchProductsFromAPI() {
        try {
            const response = await fetch(`${API_BASE_URL}/products/`);
            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }
            const apiProducts = await response.json();
            
            // Transform API data to match frontend format
            return apiProducts.map(product => {
                // ... existing transformation logic ...
                let tags = [];
                
                if (product.title.toLowerCase().includes('adventure') || product.title.toLowerCase().includes('mountain')) {
                    tags.push('trending');
                }
                
                if (product.title.toLowerCase().includes('striped') || product.title.toLowerCase().includes('coral')) {
                    tags.push('new-arrivals');
                }
                
                if (product.title.toLowerCase().includes('forest') || product.title.toLowerCase().includes('green')) {
                    tags.push('sale');
                }
                
                tags.push(product.category);
                
                return {
                    id: product.id,
                    name: product.title,
                    price: product.price,
                    category: product.category,
                    tags: tags,
                    image: getProductImageClass(product.title),
                    imageUrl: `${API_BASE_URL}${product.image_url}`,
                    description: product.description,
                    quantity: product.quantity
                };
            });
        } catch (error) {
            console.error('API not available, using static data:', error);
            
            // Fallback to static products if available
            if (window.STATIC_PRODUCTS) {
                return window.STATIC_PRODUCTS.map(product => ({
                    id: product.id,
                    name: product.title,
                    price: product.price,
                    category: product.category,
                    tags: [product.category],
                    image: getProductImageClass(product.title),
                    imageUrl: product.images.main,
                    description: product.description,
                    quantity: product.quantity
                }));
            }
            
            // Final fallback to hardcoded sample products
            return getStaticProducts();
        }
    }
"""
            
            # Insert the fallback logic after the existing fetchProductsFromAPI function
            html_content = html_content.replace(
                '        // Fallback static products (in case API is not available)',
                js_fallback + '\n        // Fallback static products (in case API is not available)'
            )
        
        with open('index.html', 'w', encoding='utf-8') as f:
            f.write(html_content)
        
        print("‚úÖ Updated index.html with static data fallback")
        
    except Exception as e:
        print(f"Error updating index.html: {e}")

def create_offline_version():
    """Create a completely offline version"""
    try:
        with open('index.html', 'r', encoding='utf-8') as f:
            html_content = f.read()
        
        # Create offline version
        offline_html = html_content.replace(
            '<title>Trendyoft - Modern Lifestyle Store</title>',
            '<title>Trendyoft - Modern Lifestyle Store (Offline)</title>'
        )
        
        # Add offline banner
        banner = '''
    <!-- Offline Mode Banner -->
    <div style="background: #dbeafe; border: 2px solid #3b82f6; padding: 1rem; text-align: center; margin-top: 80px; z-index: 1001; position: relative;">
        <strong>üåê Offline Mode</strong> - Viewing cached products. Start server for live data and admin features.
    </div>
'''
        
        offline_html = offline_html.replace(
            '    <!-- Navigation -->',
            banner + '    <!-- Navigation -->'
        )
        
        with open('index_offline.html', 'w', encoding='utf-8') as f:
            f.write(offline_html)
        
        print("‚úÖ Created index_offline.html for completely offline use")
        
    except Exception as e:
        print(f"Error creating offline version: {e}")

def main():
    """Main function"""
    print("üöÄ Generating Static Site with Database Products")
    print("=" * 50)
    
    # Generate static products JavaScript file
    product_count = generate_static_products_js()
    
    # Update main index.html with fallback support
    update_index_html()
    
    # Create completely offline version
    create_offline_version()
    
    print("\n" + "=" * 50)
    print("‚úÖ Static site generation completed!")
    print(f"üìä Products exported: {product_count}")
    print("\nüìÅ Files created/updated:")
    print("   ‚Ä¢ static_products.js - Products data file")
    print("   ‚Ä¢ index.html - Updated with offline fallback")
    print("   ‚Ä¢ index_offline.html - Complete offline version")
    
    print("\nüéØ Usage:")
    print("   ‚Ä¢ Server running: Use index.html (gets live data)")
    print("   ‚Ä¢ Server stopped: index.html automatically uses static data")
    print("   ‚Ä¢ Completely offline: Open index_offline.html")
    
    print("\nüí° Tip: Run this script after adding new products to update static data!")

if __name__ == "__main__":
    main()
